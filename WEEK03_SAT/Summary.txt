호스트pc >> 고정 ip 값
	vmware  
		1. 마운트 하는데 도움을 줌 (하드디스크 ... )
			: 물리적 기계를 논리적 기계에 연결
			
		2. ip 값을 외부 내부로 전달


리눅스 관리자로써의 기본 역할
서버 구축시 알아야할 개념, 명령어

파일을 교환하는법
	1. 원본파일을 이메일로 주고받기 
		: 크기에 제한이 있음
	2. iso 파일화 해서 주고받기
		: 압축형식이 iso 라는 것
		; 프로그램 설치하잔게 아니다


시작 종료방법
	: 데스크 탑일경우(x윈도우일경우) 컴퓨터 끄기를 누름
		: 루트 유저가 아닐 경우 종료시킬 수가 없고(로그아웃만 가능) 루트 유저만 (시스템 종료) 가능 


가상콘솔
런레벨
마운트
사용자 및 그룹
에디터 사용법(vim . nano)

초기화 합시다 >> 스냅숏을 올려놓자


로그아웃 logout
	: 시스템 종료(halt << 루트에서만 가능)와 다른 것
	: "현재" 사용자의 (다른 사용자까지 그런게 아님) 시스템 접속을 끝낸다는거지  ,시스템 자체를 종료한다는 말이 아님
	logout
	exit
		: 터미널 창에서 입력하면 터미널 "창"만 빠져나옴 . 쉘만 빠져나옴
		:

명령어
	pwd == print working directory
		: 현재 경롤르알려줌
 
 	cd + 암것도 안치기
		: 사용자(루트든 계정자든)의 홈 디렉토리로 이동

	"루트" 사용자로써 시스템종료 방법 
	poweroff
	shutdown -P now
		: 관리자로써 많이 쓰는 명령어임
		shutdown -P +n
			: n 분뒤에 종료
			:
		
			: n시간에 재부팅
		shutdown -c 
			 예약된 셧다운취소
		shutdown -k +n
			: ㄱ{정자에게 n분뒤 종료된다는 메세지가 보내지지만 실제로 종료는 안됨
	halt -p
	init 0
		init n 
			: initalize
			: 콘솔에서 쓴다 (터미널에선 잘 안먹히는 거 많다)
			: n =0~6 == 런레벨
				: n 따라서 하는 기능이 다름
				: 0 == 시스템 종료
				: 1 == 싱글 유저 모드
					: 최소한의 서비스만 함
				: 2 == 멀티 유저 모드 << 거의 안씀
				: 3 == 멀티 유저 모드
					: 텍스트 모드에서 
				: 4 == 멀티 유저 모드 << 잘 안씀
				: 5 == 그레픽 모드
					: x 윈도우 시스템과 함께 시작
				: 6 == 리부팅




systemd 폴더 >> 초기화 관련 내용 있음
	
systemctl
	: 사용자 수준에서 systemd 를 컨트롤 하기 위해선 systemctl 을 이용하면 됨 
		: systemd (System Daemon) == unix 시스템이 부팅될때 가장 먼저 생성되어 다른 프로세스를 실행하는 init 역할을 하는 Daemon

systemctl statue
	: 런레벨이란 가정 하에 어떠한 프로그램이 실행중인지 보여줌
	: 빠져나깔땐 q 명령어 사용 << ?? 안되는디
	: gdm.service
		: gdm == x 윈도우
		
systemctl start 서비스명
	: 서비스명 >> gdm.service 같은거

systemctl stop 서비스명
	: 서비스 중지

systemctl restart 서비스명
	: 서비스 재시작

systemctl poweroff
	:
systemctl reboot
	: init 0
systemctl --help
	: 옵션 종류 확인
systemctl list-units 
	: 현재 메모리에 올라와있는 서비스를 확인


kill unit
	: stop 이랑 비슷하긴 함 근데 다른거임
	: 특정 계정자를 골라서 다운시킬 수 있음


ctrl c == 캔슬



systemctl start 서비스명



계정자는 home 이란 디렉터릴를 벗어날 수 없다
	: cd 하고 pwd 했을때 /home/계정자명 으로 뜬다

터미널
	: 우분투에서 오른쪽 버튼 눌러서 나오는거
	: exit ,halt -p, shutdown -P +n ...>> 먹힘
	: logout >> 안먹힘 

가상콘솔창
	: ctrl + alt + F2,3,4,5,6,7
		F2 >> 루트
		F3 ,,, >> 사용자
		F4 >>
		F
	: ttyn >> n번째 가상콘솔창
root 에서 halt -p + n 하고 ctrl+alt+Fn 이용해서 창 바꾸면 BroadCast message 로 뜬다

	: logout 같은거 먹힘

who
	:  어느 계정자가 시스템에 접속해있는지 보여줌	
	: ttyn >> 가상콘솔창 몇번에 켜져있다
	: 112.168.111.n >> 뭐 인터넷 같은거로 접속해있다

who | grep 계정자명
	: 특정사용자 대해 더 자세한 정보 알아냄
	: | == or


pkill -KILL -u 사용자명 &&  shutdown -h now
	:  특정사용자를 로그아웃 시키고 시스템 종료를 시키겠다
	: 프로세스 킬
	: && == and 연산자
	: 실제 서버까지 종료가 됨

아아ㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏ

실제론 서버는 다운이 되면 안된데

런레벨
cd /lib/systemd/system
la -l runlevel?.target 

==  ls -l /lib/systemd/system/runlevel?.target

	:runlevelN 
		: N == 0~6
	: ->  == 가리킨다
		: 각 런레벨은 타겟파일과 연결되어있다== 연결파일이다
		: 링크파일 == 바로가기 아이콘과 비슷한 느낌
	: x윈도우가 실행되는것 == 런레벨5  (graphical.target)
	: 텍스트 모드로 부팅되는 것 == 런레벨 3 (multiuser.target)
	: 런레벨 변경하는 법
		:  바꾸는 대상을 바꾸면 런레벨도 바뀐다(-> 뒤의 대상을 바꾼다)
(1)
ln -sf /lib/systemd/multi-user.target /lib/systemd/system/default.target
	: 중간에 한칸 꼭 띄워야됨
	: ln == link 걸겠다
	: sf
		-s 심볼
			: 심볼릭 링크를 생성하는 옵션. 원본 파일이나 디렉토리의 경로를 가리키는 역할
		-f 포멧
			:  이미 존재하는 대상파일이나 디렉토리를 덮어쓰기 위한 옵션.
	: default.target을 multi-user.target 로 설정하겠다	
	: reboot 시킴 콘솔모드로 열림



엑스모드로 여는법
(1)startx
(2) init 5
(3) systemctl restart gdm.service




rwx == 권한 
	: 읽고 쓰고 지우고
ㅣ == 링크 파일이란 의미

rwx rwx rwx 
	: --- 로 있음 권한 없는거

자동완성 히스토리 기능
	: tab 치면 . 방향ㅋ키 위아래로 움직이면 . 어케 자동완성되는걸까
	: 자동완성 >> 일부만 써도 자동 완성되는것
	: history 명령어 쓰면 그간 썼던 명령어들이 쫘라락 내역이 뜬다
		: 셀세션동안 실행한 명령어의 리스트를 보여주는 명령어
		: 특ㅈ정 번호 픽해서 다시실행한는건 history 자체에 내장되어있진 않다
			: !인덱스 하면 해당 번째의 명령어 다시 실행시켜준다
			: !! == 마지막 썼던 명령어

cd  
	: 해당 사용자의 홈 디렉터리(~) 로 이동
	: 계정자의 경우 /home/계정자명/ 이다
cd /
	: 루트 디렉터리. 최상위 디렉터리
	: /root/ 랑은 또 다른거임 << 관리자의 홈 디렉터리


gedit
	: x윈도서 제공하는 편리한 에디터.
	: 터미널 창에서 사용 가능

vi 에디터
	: 불완전 종료 ) 제대로 저장했어도 들어가봄 오류 메시지 뜸
		: swap 파일로 저장되있는 상태이므로 기절하지 말자. 

	: 앞에 점 하나 찍히고 시작하는 파일 >> 숨김파일

shell
	Bash 쉘 >> 기본
	Csh 쉘
	Korn 수ㅐㄹ
	: 쉘 >> 터미널서 명령어 쓸때 시스템과 소통하도록 도와주는 툴

man 도움말 사용법
	: manual 의 약자
	: 명령어의 모든 옵션들을 보여줌


마운트 >> 불러들이겠다
	: 물리적인 장치를 특정한 위치에 연결하는 것
플러그앤 플레이 pnp
	: 전원 들어가면 자동으로 읽어들인다

cd /
mount
	Server Pc 에 마운트된 장치들을 확인할 수 있다
	리눅스 운영체제서는 A B C 가 다 있다 (윈도우는 A , B 는 플로피로 빠져서 없다)
	: 뭐가 시스템 상에 올라와있는지 확인하게 해준다

/dev/sda2 on / type ext4
	: 디바이스의 sda2의 하드웨어 장치가 on 상태고 ext4 타입이다
		: 그리고 / 가 루트다
	: 처음에 Server 가상컴터 만들때 /dev/sda2 에 810..MB 로 설정했기 때문에 물리저깅ㄴ 장치가 루트(/)라는 공간에 연결된것


ls -l/dev/cdrom
	: 하면 나온거 보면
		: /dev/cdrom 이라는 폴더에 들어가서 sr0 내용을 볼 수있다. sr0 는 링크파ㅣㄹ? 이다
		: sr0  은 cdrom 을 나타내는 표현임



>> 에서 동글뱅이 우클릭
	: iso 폴더 불러올 수 있다.	
	: /dev/sr0 on/media/root/ubuntu 로 불러와진다
cd/ ... tab 해서 자동 완성해서 미디어 방으루ㅗ 간다
cd casper/ 
iso 파일 형식으로 파일을 주고 받겠다.
실질적으로 하드웨어가 붙어있는 리눅스의 경우 디바이스의 cdrom 으로 가야되는거고 연결 해제하려면 umount해야된다/

umou	nt 는 저장된 위치서 실행함 안되고 다른데서 가서 umount /dev/ddrom 해야된다.
	: 안그럼 busy 하다고 뜬다

확실하게 언마운트 하기 위해선 다시 동글뱅이 누르고 physical 로 전환해야도니다.


	



umount 
	: un mount 하겠단 것
	: 연결된 장치를 해제하겠단것
cd-rom
	: q
