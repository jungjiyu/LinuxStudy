ls -l 했을때 앞에 나오는 거 >> 디렉토리여부/소유자/그룹소유자/기타관련인
	: rwx == 읽기 쓰기 실행

ls 옵션 " 경로 " 도 가능 >> 해당 경로에 있는 내용 출력
	: 경로에 파일만 쓰면 해당 파일에 대한 내용만 출력해줌
	: 폴더를 쓰면 그 폴더 내의 정보 출력

~ == 물결무늬 == 틸드
	: cd ~XXX == XXX의 홈디렉터리로 이동

파이프 라인쓰면 명령어 여러개 쓸 수 있음

pwd > 어쩌구.txt
	: 어쩌구.txt 란 이름으로 현재 디렉터리 내용을 저장해줌(?_

rm 
	: 파일도 지우지만 디렉터리까지 지워버림
	: - i >> 삭제시 메세지 출력
	: -f >> 강제 삭제 (메시지 없이)
	: -r >> 재귀적으로 삭제 (하위 파일 까지)(폴더 삭제 가능)

cp 파일이나 디렉터릴를 복사
	: 새로 보ㄱ사한 파일은 복사한 사용자의 소유가 됨


touch
	: 크기가 0인 파일 생성
	: 이미 존재하는 파일이었다면 파일의 수정시간만 변경함
	: touch 파일명 으로 사용함
 

굳이 작업할 폴더로 안가고 /를 사용해서 표현 가능
	: ex ) touch tmp/file1
		: file1 을 tmp 디렉터리 아래에 만든다
	: tip >> 경로 부분에서 끝이 / 로 끝나면 디렉터리인거고 / 로 안끝남 파일인거임
		: 만약에 해당 파일이 없음 그 파일명으로 새로 파일 만들어즈ㅜㄴ다.
		: 젤 앞에 / 가 없음 현재 디렉터리를 기준으로 하는 상대경로라는 의미임

!번호 == 해당 인덱스의 history 내용 실행

mkdir
	: -p >> 만약 부모디렉터리가 없음 새로 생성해준다
		mkdir -p ex1/ex2/ex3/ex4/ex5 하면 실제로 에러없이 다 만들어진다

mv 
	1. mv 대상1 대상2 대상3 ... 경로
		: 대상 1, 대상 2 ,... 를 마지막에 쓴 경로로 옮긴다
		: 대상123.. 을 굳이 현재 디렉터리 내의 파일로 할 필요 없고 다른 디렉터리의 파일을 대상으로 할 수 있다. (걍 파일의 경로를 씀 된다.)

	2. mv 대상1 대상2
		: 대상 1 을 대상2 로 이름을 바꾼다
		: 그러니까 마지막에 경로를 안씀 이름을 바꾸는 거다.


rmdir
	: 폴더를 지운다
	: 만약에 폴더 내에 뭔가 있음 rmdir 로 못지우고 rm - r 해야된다.
		: 만약에 rmdiir 로 굳이 지우고 싶다면 하위 폴더부터 차례대로 지워가야된다.


cat 
	: concatenate 의 약자.
	: (여러개의) 파일의 내용을 (연결하여) 보여준다
	: > 사용하면 새로운 내용의 파일을 여러줄을 내용으로하여 생성 가능
		: ctrl + d ㄹ ㅗ 입력 종료

echo
	: '>'
		: 첨부터 다시 씀
		: wirte 기능
	: '>>' 리다이렉션  : 맨 뒷줄 추가
		: append 기능

head, tail
	: 맨 윗, 아랫줄서 10행만 화면에 출력
	: head or tail + 경로 로 활용
	: 옵션 -숫자
		: 10 줄이 아니라 해당 숫자줄만큼 맨 윗 아랫줄서 출력
			: 10 이상도 가능


less , more
	: 조금ㅁ씩 보여준다 , 많이 보여준다
	: less 의 경우 방향키로 한줄 단위로 움직일 수 있다(more 은 안됨)
	: space bar == 담 페이지
	: q == 종료
	: " less혹은more 파일 " 의 형태로 사용한다
	: 중간에 +숫자 넣으면 그 줄 부터 읽기 시작한다



file 명령어
	:: 해디ㅏㅇ 파일이 어떤 종류의 파일인지 보여주다
		: type 를 보여주는 거랑 비슷

내용 확인 하는 ㅂ버 ㅂ 5가지
	: cat 
	: less
	: more
	: head
	: tail



이미지 파일 생성 방법
	: 뭐 쓴ㄴ다 어쨌뜬 명령어 창에서도 이미지 파일을 생성할 수 있더라



사용자 관리와 파일 속성 알아보기
	리눅스 == 다중 사용자 시스템
		: 1대의 리눅스에 여러명이 동싱 접속해서 쓸 수 있다
		: 유저
			: root == 슈퍼유저
				: 모든 권한이 있다
			: 모든 유저는 혼자 존재하는게 아니라 하나 이상의 그룹에 속해있어야된다
			: home 아래에 계정자가 생성이 되면 뭔가 그 계정자가 작업할 공간을 따로 만들어줘야된다

	파일 관리를 위해서는 파일 속성을 알아야됨

	gedit /etc/passwd

		root:x:0:0:root:/root:/bin/bash
		사용자명:password:uid:gid 이고 홈디렉터리는 /root 이고 작업공간은 /bin/bash 를 이용하고 있다
			: password
				: x 로 표기되이씅ㅁ 설정되있던것
			: uid == 사용자id
			: groupid == 그룹id
			: 계정자한테 루트사용자의 그룹id를 그 계정자도 루트 사용자가 된다

		ubuntu:x:1000:1000:Ubuntu,,,:/home/ubuntu:/bin/bash
		사용자명:비밀번호:uid:gid: 이고 가운데는 추가정보고 마지막부분은 홈디렉터리는 /home/ubuntu 이고 작업 공간은 /bin/bash 를 이용하고 있다고 해석
			: 가운데 부분 == 추가정보 ) 저ㄴ체 이름, 사무실 호수 같은 거


	less /etc/shadow
		: 비밀번호 확인>> 암호화 되서 저장되어있는 걸 확인 가능(비밀번호 같게 설정해도 다 다르게 보임)
			root:$6$u45PgcY9qbSmcg3/$Ivok30LYJHMu6kpZLDAKVYn1zSN/18X5zhffE/U4c.YtuZ9v2FhhvwF
5Zbaa37kOpjqENhnt21pxPuTF6d9gY.:19729:0:99999:7:::


			ubuntu:$6$7z6fpXZs1vA0Z/./$kDDlEGld5UzqHfE5KwXEYkwNBFNueuM6omCLhMQlTPK0asiW/f6aLUXDM2unbk6FpZUAJPG.zSMV2lyJeB/z90:19729:0:99999:7:::
		

	less /etc/group
		: group 을 관리하는 파일
		root:x:0:
			: gid 가 0 번이다
		ubuntu:x:1000:
			: gid 가 1000번이다		
				: 만약 : 뒤에 뭐 더 있음 ubuntu와 같은 공간을 쓰는거다
				

	사용자 관련 명령어
		: adduser
			: 사용자 추가
			: adduser 사용자명
				: 하면 나오는거			
				: 암호 생성 >> 암호 입력
				: 이름. 방번호 ,전화번ㄴ호,직장전번,기타>> 알아서 입력

			: adduser --uid 사용자id 사용자명
				: uid 를 직접 지정 가능
				: gid 도 그 아이디로 지정됨

			: adduser --gid 사용자id 사용자명
				: gid 를 직접 지정 가능
				: uid 까지 그렇게 되진 않음

			: adduser --home 디렉터리명 사용자명
				: home 디렉터리 직접 지정 가능
					: 이렇게 함 /home 에 해당 사용자의 파일이 만들어지지 않고 지정한 디렉터리에 만들어지는데 해당 디텍터리가 새로 만들어지긴 하지만 따로 /home 에 만들어지는 것처럼 이쁘게 디렉터리로 저장되진 않는다(지정한 디렉터리 아래에 서브 디렉터리가 만들어지진 않는다)
 
			: adduser --shell 디렉터리명 사용자명
				: 쉘을 직접 지정함 (bash shell , c shell 등 다양 )


		: less /etc/passwd/

		: passwd 계정자명
			:sticky bit >> 일반 사용자도 그 파일을 링크식으로 끌어다 쓸 수 있다
			: 왜그런지 몰라도 관리자 권한이 필요하진 않다

		: usermod 사용자명
			: 사용자를 생성한 이후에 뭔가 바꾸겠다
			: usermod --shell 경로 사용자명
				: 쉘을 바꾸겠다

			: usermod --groups 사용자명1 사용자명2
				: 사용자명1 의 그룹에 사용자명2가 들어간다
					: tail /etc/group 했을때 사용자명1: 뒤에 사용자명2가 추가되어있다
					: 근데 tail /etc/passwd 했을땐 변함이 없다. 그래도 사용자명2가 사용자명1의 워킹디렉터리의 자원을 가져다쓸 수 있단 것 같다
			
			: usermod 실행어쩌구저쩌구 > 파일명.txt 2>&1
				: 현재 디렉터리에 파일명.txt 로 에러사항이 저장된다
				: 2>&1 의미 ) 표준 에러를 출력하겠다
					: 숫자 0 == stdin
					: 숫자 1 == stdout
					: 숫자 2 == stderr
						

		: userdel 사용자명
			: 사용자를 삭제한다. 관리자 권한으로 해야한다
				: 근데 홈 디렉터리는 빼고 삭제한다		
					: cd /home 로 가서 확인해봄 여전히 있다
					: 이제 더이상 로그인이 불가능해지지만 그동안 했던 작업 내용은 그대로 남아있는거다
			: 근데 /etc/shadow 에서 주석문 처리만 해도 같은 효과가  나긴 하다
			: userdel -r 사용자명
				: 홈디렉터리까지 없어진다.

		: > == 파이프라인. 뭘 내ㅐ보내겟다
			: 2라고 하는 표준 출력을 파일로 저장해서 뭐 음 음..?


	getent 데이터베이스 타겟
		: 데이터베이스에서 타겟을 찾아내겠다


	chage
		: 사용자의 암호를 주기적으로 변경하도록 설정한디
		: chage -l 계정잠명
			: 해당 계정자에대한 설정 사항 확인
		: chage -m 숫자 계정자명
			: 해당 계정자가 암호룰 바꿀 수 있는 최소 일자 정하기 (최소 n 일 이후에 패스워드 바꿀 수 있다)
				: 물론 루트 ㅅ사용자 차원에선 걍 바꿀 수 있다

		: chage -M 숫자 계정자명
			: 해당 계정자가 암호를 바꿔야 되는 최대 일 수 정하기

		: chage -E XXXX/XX/XX
			: 해당 계정의 만료일 설정

		: chage -W 숫자 계정자명
			: 암호 만료 예고일 설정



	journalctl --since "날짜 시간" > 파일명.txt 
		: 시스템ㅁ 오류 , 진행 사항 같은 걸 설정한 시간 이후부터 파일이 만들어진 시점까지 발생한걸 보여준다

	groups
		: 그냥 groups 
			: 현재 그룹에대한 정보 보여준다
		: groups 계정자명
			: 속한 그룹이 나타남

	groupadd 그룹명
		: 그룹 생성
		: tail /etc/group 에서 확인 가능
			: 혹은 getent group 그룹명 으로 바로 확인 가능
		: groupadd --gid 넘버 그룹명
			: gid 값을 직접 설정

	groupmod
		: 이미 생성한 그룹의 속성을 바꾼다
		: groupmod --new-name 새그룹명 이전개발명
			: 그룹 이름 변경


	groupdel 
		: groupdel 그룹명
		: 해당 그룹이 삭제되면 해당 그룹에 속한 사용자들에게 영향이 발생 . 그룹을 삭제하기 이전에 해당 그룹에 속한 계정자를 먼저 바꾸고 삭제해야됨
			: group
				
	rwx 각 자리에 421 의 가중치가 부여되있다
		: sticky bit == s 자가 들어가 있는 것. 계정자도 뭔가 관리자처럼 끌어쓸 수 있는 명령어


